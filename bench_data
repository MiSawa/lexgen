Lexer(LexerState) -> Token<'input>;

let whitespace = [' ' '\t' '\n'] | "\r\n";

// > Names (also called identifiers) in Lua can be any string of letters, digits, and
// > underscores, not beginning with a digit. This coincides with the definition of names in
// > most languages. (The definition of letter depends on the current locale: any character
// > considered alphabetic by the current locale can be used in an identifier.)
let var_init = ['a'-'z' 'A'-'Z' '_'];
let var_subseq = $var_init | ['0'-'9'];

let digit = ['0'-'9'];
let hex_digit = ['a'-'f' 'A'-'F' '0'-'9'];

rule Init {
    $whitespace,

    "+" = Token::Plus,
    "-" = Token::Minus,
    "*" = Token::Star,
    "/" = Token::Slash,
    "%" = Token::Percent,
    "^" = Token::Caret,
    "#" = Token::Hash,
    "==" = Token::EqEq,
    "~=" = Token::TildeEq,
    "<=" = Token::LtEq,
    ">=" = Token::GtEq,
    "<" = Token::Lt,
    ">" = Token::Gt,
    "=" = Token::Eq,
    "(" = Token::LParen,
    ")" = Token::RParen,
    "{" = Token::LBrace,
    "}" = Token::RBrace,
    "]" = Token::RBracket,
    ";" = Token::Semicolon,
    ":" = Token::Colon,
    "," = Token::Comma,
    "." = Token::Dot,
    ".." = Token::DotDot,
    "..." = Token::DotDotDot,
    "and" = Token::Keyword(Keyword::And),
    "break" = Token::Keyword(Keyword::Break),
    "do" = Token::Keyword(Keyword::Do),
    "else" = Token::Keyword(Keyword::Else),
    "elseif" = Token::Keyword(Keyword::ElseIf),
    "end" = Token::Keyword(Keyword::End),
    "false" = Token::Keyword(Keyword::False),
    "for" = Token::Keyword(Keyword::For),
    "function" = Token::Keyword(Keyword::Function),
    "if" = Token::Keyword(Keyword::If),
    "in" = Token::Keyword(Keyword::In),
    "local" = Token::Keyword(Keyword::Local),
    "nil" = Token::Keyword(Keyword::Nil),
    "not" = Token::Keyword(Keyword::Not),
    "or" = Token::Keyword(Keyword::Or),
    "repeat" = Token::Keyword(Keyword::Repeat),
    "return" = Token::Keyword(Keyword::Return),
    "then" = Token::Keyword(Keyword::Then),
    "true" = Token::Keyword(Keyword::True),
    "until" = Token::Keyword(Keyword::Until),
    "while" = Token::Keyword(Keyword::While),

    '"' => |mut lexer| {
        lexer.state().short_string_delim = Quote::Double;
        lexer.state().string_buf.clear();
        lexer.switch(LexerRule::String)
    },

    '\'' => |mut lexer| {
        lexer.state().short_string_delim = Quote::Single;
        lexer.state().string_buf.clear();
        lexer.switch(LexerRule::String)
    },

    "[" => |mut lexer| {
        match lexer.peek() {
            Some('[') | Some('=') => {
                lexer.state().long_string_opening_eqs = 0;
                lexer.state().in_comment = false;
                lexer.switch(LexerRule::LongStringBracketLeft)
            }
            _ => lexer.return_(Token::LBracket),
        }
    },

    "--" => |lexer| {
        lexer.switch(LexerRule::EnterComment)
    },

    $var_init $var_subseq* => |lexer| {
        let match_ = lexer.match_();
        lexer.return_(Token::Var(match_))
    },

    $digit+ ('.'? $digit+ (('e' | 'E') ('+'|'-')? $digit+)?)? =>
        |lexer| {
            let match_ = lexer.match_();
            lexer.return_(Token::Number(match_))
        },

    "0x" $hex_digit+ => |lexer| {
        let match_ = lexer.match_();
        lexer.return_(Token::Number(match_))
    },
}

rule LongStringBracketLeft {
    '=' =>
        |mut lexer| {
            lexer.state().long_string_opening_eqs += 1;
            lexer.continue_()
        },

    '[' =>
        |lexer|
            lexer.switch(LexerRule::LongString),
}

rule LongString {
    ']' =>
        |mut lexer| {
            lexer.state().long_string_closing_eqs = 0;
            lexer.switch(LexerRule::LongStringBracketRight)
        },

    _ =>
        |lexer|
            lexer.continue_(),
}

rule LongStringBracketRight {
    '=' =>
        |mut lexer| {
            lexer.state().long_string_closing_eqs += 1;
            lexer.continue_()
        },

    ']' =>
        |mut lexer| {
            let state = lexer.state();
            let in_comment = state.in_comment;
            let left_eqs = state.long_string_opening_eqs;
            let right_eqs = state.long_string_closing_eqs;
            if left_eqs == right_eqs {
                if in_comment {
                    lexer.switch(LexerRule::Init)
                } else {
                    let match_ = &lexer.match_[left_eqs + 2..lexer.match_.len() - right_eqs - 2];
                    lexer.switch_and_return(LexerRule::Init, Token::String(StringToken::Raw(match_)))
                }
            } else {
                lexer.switch(LexerRule::String)
            }
        },

    _ =>
        |lexer|
            lexer.switch(LexerRule::String),
}

rule String {
    '"' => |mut lexer| {
        if lexer.state().short_string_delim == Quote::Double {
            let str = lexer.state().string_buf.clone();
            lexer.switch_and_return(LexerRule::Init, Token::String(StringToken::Interpreted(str)))
        } else {
            lexer.state().string_buf.push('"');
            lexer.continue_()
        }
    },

    "'" => |mut lexer| {
        if lexer.state().short_string_delim == Quote::Single {
            let str = lexer.state().string_buf.clone();
            lexer.switch_and_return(LexerRule::Init, Token::String(StringToken::Interpreted(str)))
        } else {
            lexer.state().string_buf.push('\'');
            lexer.continue_()
        }
    },

    "\\a" => |mut lexer| {
        lexer.state().string_buf.push('\u{7}');
        lexer.continue_()
    },

    "\\b" => |mut lexer| {
        lexer.state().string_buf.push('\u{8}');
        lexer.continue_()
    },

    "\\f" => |mut lexer| {
        lexer.state().string_buf.push('\u{c}');
        lexer.continue_()
    },

    "\\n" => |mut lexer| {
        lexer.state().string_buf.push('\n');
        lexer.continue_()
    },

    "\\r" => |mut lexer| {
        lexer.state().string_buf.push('\r');
        lexer.continue_()
    },

    "\\t" => |mut lexer| {
        lexer.state().string_buf.push('\t');
        lexer.continue_()
    },

    "\\v" => |mut lexer| {
        lexer.state().string_buf.push('\u{b}');
        lexer.continue_()
    },

    "\\\\" => |mut lexer| {
        lexer.state().string_buf.push('\\');
        lexer.continue_()
    },

    "\\\"" => |mut lexer| {
        lexer.state().string_buf.push('"');
        lexer.continue_()
    },

    "\\'" => |mut lexer| {
        lexer.state().string_buf.push('\'');
        lexer.continue_()
    },

    "\\\n" => |mut lexer| {
        lexer.state().string_buf.push('\n');
        lexer.continue_()
    },

    _ => |mut lexer| {
        let char = lexer.match_().chars().next_back().unwrap();
        lexer.state().string_buf.push(char);
        lexer.continue_()
    },
}

rule EnterComment {
    '[' => |mut lexer| {
        match lexer.peek() {
            Some('[') | Some('=') => {
                lexer.state().long_string_opening_eqs = 0;
                lexer.state().in_comment = true;
                lexer.switch(LexerRule::LongStringBracketLeft)
            }
            _ =>
                lexer.switch(LexerRule::Comment),
        }
    },

    _ => |lexer|
        lexer.switch(LexerRule::Comment),
}

rule Comment {
    '\n' => |lexer|
        lexer.switch(LexerRule::Init),

    _ => |lexer|
        lexer.continue_(),
}
